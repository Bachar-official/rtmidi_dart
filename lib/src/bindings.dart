// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Generated bindings for RtMidi
class RtMidiFFI {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RtMidiFFI(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RtMidiFFI.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// ! \brief Determine the available compiled MIDI APIs.
  ///
  /// If the given `apis` parameter is null, returns the number of available APIs.
  /// Otherwise, fill the given apis array with the RtMidi::Api values.
  ///
  /// \param apis  An array or a null value.
  /// \param apis_size  Number of elements pointed to by apis
  /// \return number of items needed for apis array if apis==NULL, or
  /// number of items written to apis array otherwise.  A negative
  /// return value indicates an error.
  ///
  /// See \ref RtMidi::getCompiledApi().
  int rtmidi_get_compiled_api(
    ffi.Pointer<ffi.Int32> apis,
    int apis_size,
  ) {
    return _rtmidi_get_compiled_api(
      apis,
      apis_size,
    );
  }

  late final _rtmidi_get_compiled_apiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int32>,
              ffi.UnsignedInt)>>('rtmidi_get_compiled_api');
  late final _rtmidi_get_compiled_api = _rtmidi_get_compiled_apiPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int32>, int)>();

  /// ! \brief Return the name of a specified compiled MIDI API.
  /// ! See \ref RtMidi::getApiName().
  ffi.Pointer<ffi.Char> rtmidi_api_name(
    int api,
  ) {
    return _rtmidi_api_name(
      api,
    );
  }

  late final _rtmidi_api_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'rtmidi_api_name');
  late final _rtmidi_api_name =
      _rtmidi_api_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! \brief Return the display name of a specified compiled MIDI API.
  /// ! See \ref RtMidi::getApiDisplayName().
  ffi.Pointer<ffi.Char> rtmidi_api_display_name(
    int api,
  ) {
    return _rtmidi_api_display_name(
      api,
    );
  }

  late final _rtmidi_api_display_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'rtmidi_api_display_name');
  late final _rtmidi_api_display_name = _rtmidi_api_display_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// ! \brief Return the compiled MIDI API having the given name.
  /// ! See \ref RtMidi::getCompiledApiByName().
  int rtmidi_compiled_api_by_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _rtmidi_compiled_api_by_name(
      name,
    );
  }

  late final _rtmidi_compiled_api_by_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'rtmidi_compiled_api_by_name');
  late final _rtmidi_compiled_api_by_name = _rtmidi_compiled_api_by_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// ! \internal Report an error.
  void rtmidi_error(
    int type,
    ffi.Pointer<ffi.Char> errorString,
  ) {
    return _rtmidi_error(
      type,
      errorString,
    );
  }

  late final _rtmidi_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Char>)>>('rtmidi_error');
  late final _rtmidi_error =
      _rtmidi_errorPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// ! \brief Open a MIDI port.
  ///
  /// \param port      Must be greater than 0
  /// \param portName  Name for the application port.
  ///
  /// See RtMidi::openPort().
  void rtmidi_open_port(
    RtMidiPtr device,
    int portNumber,
    ffi.Pointer<ffi.Char> portName,
  ) {
    return _rtmidi_open_port(
      device,
      portNumber,
      portName,
    );
  }

  late final _rtmidi_open_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(RtMidiPtr, ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('rtmidi_open_port');
  late final _rtmidi_open_port = _rtmidi_open_portPtr
      .asFunction<void Function(RtMidiPtr, int, ffi.Pointer<ffi.Char>)>();

  /// ! \brief Creates a virtual MIDI port to which other software applications can
  /// connect.
  ///
  /// \param portName  Name for the application port.
  ///
  /// See RtMidi::openVirtualPort().
  void rtmidi_open_virtual_port(
    RtMidiPtr device,
    ffi.Pointer<ffi.Char> portName,
  ) {
    return _rtmidi_open_virtual_port(
      device,
      portName,
    );
  }

  late final _rtmidi_open_virtual_portPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(RtMidiPtr, ffi.Pointer<ffi.Char>)>>(
      'rtmidi_open_virtual_port');
  late final _rtmidi_open_virtual_port = _rtmidi_open_virtual_portPtr
      .asFunction<void Function(RtMidiPtr, ffi.Pointer<ffi.Char>)>();

  /// ! \brief Close a MIDI connection.
  /// See RtMidi::closePort().
  void rtmidi_close_port(
    RtMidiPtr device,
  ) {
    return _rtmidi_close_port(
      device,
    );
  }

  late final _rtmidi_close_portPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(RtMidiPtr)>>(
          'rtmidi_close_port');
  late final _rtmidi_close_port =
      _rtmidi_close_portPtr.asFunction<void Function(RtMidiPtr)>();

  /// ! \brief Return the number of available MIDI ports.
  /// See RtMidi::getPortCount().
  int rtmidi_get_port_count(
    RtMidiPtr device,
  ) {
    return _rtmidi_get_port_count(
      device,
    );
  }

  late final _rtmidi_get_port_countPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(RtMidiPtr)>>(
          'rtmidi_get_port_count');
  late final _rtmidi_get_port_count =
      _rtmidi_get_port_countPtr.asFunction<int Function(RtMidiPtr)>();

  /// ! \brief Access a string identifier for the specified MIDI input port number.
  ///
  /// To prevent memory leaks a char buffer must be passed to this function.
  /// NULL can be passed as bufOut parameter, and that will write the required buffer length in the bufLen.
  ///
  /// See RtMidi::getPortName().
  int rtmidi_get_port_name(
    RtMidiPtr device,
    int portNumber,
    ffi.Pointer<ffi.Char> bufOut,
    ffi.Pointer<ffi.Int> bufLen,
  ) {
    return _rtmidi_get_port_name(
      device,
      portNumber,
      bufOut,
      bufLen,
    );
  }

  late final _rtmidi_get_port_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(RtMidiPtr, ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('rtmidi_get_port_name');
  late final _rtmidi_get_port_name = _rtmidi_get_port_namePtr.asFunction<
      int Function(
          RtMidiPtr, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>();

  /// ! \brief Create a default RtMidiInPtr value, with no initialization.
  RtMidiInPtr rtmidi_in_create_default() {
    return _rtmidi_in_create_default();
  }

  late final _rtmidi_in_create_defaultPtr =
      _lookup<ffi.NativeFunction<RtMidiInPtr Function()>>(
          'rtmidi_in_create_default');
  late final _rtmidi_in_create_default =
      _rtmidi_in_create_defaultPtr.asFunction<RtMidiInPtr Function()>();

  /// ! \brief Create a  RtMidiInPtr value, with given api, clientName and queueSizeLimit.
  ///
  /// \param api            An optional API id can be specified.
  /// \param clientName     An optional client name can be specified. This
  /// will be used to group the ports that are created
  /// by the application.
  /// \param queueSizeLimit An optional size of the MIDI input queue can be
  /// specified.
  ///
  /// See RtMidiIn::RtMidiIn().
  RtMidiInPtr rtmidi_in_create(
    int api,
    ffi.Pointer<ffi.Char> clientName,
    int queueSizeLimit,
  ) {
    return _rtmidi_in_create(
      api,
      clientName,
      queueSizeLimit,
    );
  }

  late final _rtmidi_in_createPtr = _lookup<
      ffi.NativeFunction<
          RtMidiInPtr Function(ffi.Int32, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('rtmidi_in_create');
  late final _rtmidi_in_create = _rtmidi_in_createPtr
      .asFunction<RtMidiInPtr Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// ! \brief Free the given RtMidiInPtr.
  void rtmidi_in_free(
    RtMidiInPtr device,
  ) {
    return _rtmidi_in_free(
      device,
    );
  }

  late final _rtmidi_in_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(RtMidiInPtr)>>(
          'rtmidi_in_free');
  late final _rtmidi_in_free =
      _rtmidi_in_freePtr.asFunction<void Function(RtMidiInPtr)>();

  /// ! \brief Returns the MIDI API specifier for the given instance of RtMidiIn.
  /// ! See \ref RtMidiIn::getCurrentApi().
  int rtmidi_in_get_current_api(
    RtMidiPtr device,
  ) {
    return _rtmidi_in_get_current_api(
      device,
    );
  }

  late final _rtmidi_in_get_current_apiPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(RtMidiPtr)>>(
          'rtmidi_in_get_current_api');
  late final _rtmidi_in_get_current_api =
      _rtmidi_in_get_current_apiPtr.asFunction<int Function(RtMidiPtr)>();

  /// ! \brief Set a callback function to be invoked for incoming MIDI messages.
  /// ! See \ref RtMidiIn::setCallback().
  void rtmidi_in_set_callback(
    RtMidiInPtr device,
    RtMidiCCallback callback,
    ffi.Pointer<ffi.Void> userData,
  ) {
    return _rtmidi_in_set_callback(
      device,
      callback,
      userData,
    );
  }

  late final _rtmidi_in_set_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(RtMidiInPtr, RtMidiCCallback,
              ffi.Pointer<ffi.Void>)>>('rtmidi_in_set_callback');
  late final _rtmidi_in_set_callback = _rtmidi_in_set_callbackPtr.asFunction<
      void Function(RtMidiInPtr, RtMidiCCallback, ffi.Pointer<ffi.Void>)>();

  /// ! \brief Cancel use of the current callback function (if one exists).
  /// ! See \ref RtMidiIn::cancelCallback().
  void rtmidi_in_cancel_callback(
    RtMidiInPtr device,
  ) {
    return _rtmidi_in_cancel_callback(
      device,
    );
  }

  late final _rtmidi_in_cancel_callbackPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(RtMidiInPtr)>>(
          'rtmidi_in_cancel_callback');
  late final _rtmidi_in_cancel_callback =
      _rtmidi_in_cancel_callbackPtr.asFunction<void Function(RtMidiInPtr)>();

  /// ! \brief Specify whether certain MIDI message types should be queued or ignored during input.
  /// ! See \ref RtMidiIn::ignoreTypes().
  void rtmidi_in_ignore_types(
    RtMidiInPtr device,
    bool midiSysex,
    bool midiTime,
    bool midiSense,
  ) {
    return _rtmidi_in_ignore_types(
      device,
      midiSysex,
      midiTime,
      midiSense,
    );
  }

  late final _rtmidi_in_ignore_typesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(RtMidiInPtr, ffi.Bool, ffi.Bool,
              ffi.Bool)>>('rtmidi_in_ignore_types');
  late final _rtmidi_in_ignore_types = _rtmidi_in_ignore_typesPtr
      .asFunction<void Function(RtMidiInPtr, bool, bool, bool)>();

  /// ! Fill the user-provided array with the data bytes for the next available
  /// MIDI message in the input queue and return the event delta-time in seconds.
  ///
  /// \param message   Must point to a char* that is already allocated.
  /// SYSEX messages maximum size being 1024, a statically
  /// allocated array could
  /// be sufficient.
  /// \param size      Is used to return the size of the message obtained.
  /// Must be set to the size of \ref message when calling.
  ///
  /// See RtMidiIn::getMessage().
  double rtmidi_in_get_message(
    RtMidiInPtr device,
    ffi.Pointer<ffi.UnsignedChar> message,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _rtmidi_in_get_message(
      device,
      message,
      size,
    );
  }

  late final _rtmidi_in_get_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(RtMidiInPtr, ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Size>)>>('rtmidi_in_get_message');
  late final _rtmidi_in_get_message = _rtmidi_in_get_messagePtr.asFunction<
      double Function(
          RtMidiInPtr, ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.Size>)>();

  /// ! \brief Create a default RtMidiInPtr value, with no initialization.
  RtMidiOutPtr rtmidi_out_create_default() {
    return _rtmidi_out_create_default();
  }

  late final _rtmidi_out_create_defaultPtr =
      _lookup<ffi.NativeFunction<RtMidiOutPtr Function()>>(
          'rtmidi_out_create_default');
  late final _rtmidi_out_create_default =
      _rtmidi_out_create_defaultPtr.asFunction<RtMidiOutPtr Function()>();

  /// ! \brief Create a RtMidiOutPtr value, with given and clientName.
  ///
  /// \param api            An optional API id can be specified.
  /// \param clientName     An optional client name can be specified. This
  /// will be used to group the ports that are created
  /// by the application.
  ///
  /// See RtMidiOut::RtMidiOut().
  RtMidiOutPtr rtmidi_out_create(
    int api,
    ffi.Pointer<ffi.Char> clientName,
  ) {
    return _rtmidi_out_create(
      api,
      clientName,
    );
  }

  late final _rtmidi_out_createPtr = _lookup<
      ffi.NativeFunction<
          RtMidiOutPtr Function(
              ffi.Int32, ffi.Pointer<ffi.Char>)>>('rtmidi_out_create');
  late final _rtmidi_out_create = _rtmidi_out_createPtr
      .asFunction<RtMidiOutPtr Function(int, ffi.Pointer<ffi.Char>)>();

  /// ! \brief Free the given RtMidiOutPtr.
  void rtmidi_out_free(
    RtMidiOutPtr device,
  ) {
    return _rtmidi_out_free(
      device,
    );
  }

  late final _rtmidi_out_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(RtMidiOutPtr)>>(
          'rtmidi_out_free');
  late final _rtmidi_out_free =
      _rtmidi_out_freePtr.asFunction<void Function(RtMidiOutPtr)>();

  /// ! \brief Returns the MIDI API specifier for the given instance of RtMidiOut.
  /// ! See \ref RtMidiOut::getCurrentApi().
  int rtmidi_out_get_current_api(
    RtMidiPtr device,
  ) {
    return _rtmidi_out_get_current_api(
      device,
    );
  }

  late final _rtmidi_out_get_current_apiPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(RtMidiPtr)>>(
          'rtmidi_out_get_current_api');
  late final _rtmidi_out_get_current_api =
      _rtmidi_out_get_current_apiPtr.asFunction<int Function(RtMidiPtr)>();

  /// ! \brief Immediately send a single message out an open MIDI output port.
  /// ! See \ref RtMidiOut::sendMessage().
  int rtmidi_out_send_message(
    RtMidiOutPtr device,
    ffi.Pointer<ffi.UnsignedChar> message,
    int length,
  ) {
    return _rtmidi_out_send_message(
      device,
      message,
      length,
    );
  }

  late final _rtmidi_out_send_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(RtMidiOutPtr, ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('rtmidi_out_send_message');
  late final _rtmidi_out_send_message = _rtmidi_out_send_messagePtr.asFunction<
      int Function(RtMidiOutPtr, ffi.Pointer<ffi.UnsignedChar>, int)>();
}

final class max_align_t extends ffi.Opaque {}

/// ! \brief Wraps an RtMidi object for C function return statuses.
final class RtMidiWrapper extends ffi.Struct {
  /// ! The wrapped RtMidi object.
  external ffi.Pointer<ffi.Void> ptr;

  external ffi.Pointer<ffi.Void> data;

  /// ! True when the last function call was OK.
  @ffi.Bool()
  external bool ok;

  /// ! If an error occured (ok != true), set to an error message.
  external ffi.Pointer<ffi.Char> msg;
}

/// ! \brief MIDI API specifier arguments.  See \ref RtMidi::Api.
abstract class RtMidiApi {
  /// !< Search for a working compiled API.
  static const int RTMIDI_API_UNSPECIFIED = 0;

  /// !< Macintosh OS-X CoreMIDI API.
  static const int RTMIDI_API_MACOSX_CORE = 1;

  /// !< The Advanced Linux Sound Architecture API.
  static const int RTMIDI_API_LINUX_ALSA = 2;

  /// !< The Jack Low-Latency MIDI Server API.
  static const int RTMIDI_API_UNIX_JACK = 3;

  /// !< The Microsoft Multimedia MIDI API.
  static const int RTMIDI_API_WINDOWS_MM = 4;

  /// !< A compilable but non-functional API.
  static const int RTMIDI_API_RTMIDI_DUMMY = 5;

  /// !< Number of values in this enum.
  static const int RTMIDI_API_NUM = 6;
}

/// ! \brief Defined RtMidiError types. See \ref RtMidiError::Type.
abstract class RtMidiErrorType {
  /// !< A non-critical error.
  static const int RTMIDI_ERROR_WARNING = 0;

  /// !< A non-critical error which might be useful for debugging.
  static const int RTMIDI_ERROR_DEBUG_WARNING = 1;

  /// !< The default, unspecified error type.
  static const int RTMIDI_ERROR_UNSPECIFIED = 2;

  /// !< No devices found on system.
  static const int RTMIDI_ERROR_NO_DEVICES_FOUND = 3;

  /// !< An invalid device ID was specified.
  static const int RTMIDI_ERROR_INVALID_DEVICE = 4;

  /// !< An error occured during memory allocation.
  static const int RTMIDI_ERROR_MEMORY_ERROR = 5;

  /// !< An invalid parameter was specified to a function.
  static const int RTMIDI_ERROR_INVALID_PARAMETER = 6;

  /// !< The function was called incorrectly.
  static const int RTMIDI_ERROR_INVALID_USE = 7;

  /// !< A system driver error occured.
  static const int RTMIDI_ERROR_DRIVER_ERROR = 8;

  /// !< A system error occured.
  static const int RTMIDI_ERROR_SYSTEM_ERROR = 9;

  /// !< A thread error occured.
  static const int RTMIDI_ERROR_THREAD_ERROR = 10;
}

/// ! \brief Typedef for a generic RtMidi pointer.
typedef RtMidiPtr = ffi.Pointer<RtMidiWrapper>;

/// ! \brief Typedef for a generic RtMidiIn pointer.
typedef RtMidiInPtr = ffi.Pointer<RtMidiWrapper>;

/// ! \brief The type of a RtMidi callback function.
///
/// \param timeStamp   The time at which the message has been received.
/// \param message     The midi message.
/// \param userData    Additional user data for the callback.
///
/// See \ref RtMidiIn::RtMidiCallback.
typedef RtMidiCCallback
    = ffi.Pointer<ffi.NativeFunction<RtMidiCCallbackFunction>>;
typedef RtMidiCCallbackFunction = ffi.Void Function(
    ffi.Double timeStamp,
    ffi.Pointer<ffi.UnsignedChar> message,
    ffi.Size messageSize,
    ffi.Pointer<ffi.Void> userData);
typedef DartRtMidiCCallbackFunction = void Function(
    double timeStamp,
    ffi.Pointer<ffi.UnsignedChar> message,
    int messageSize,
    ffi.Pointer<ffi.Void> userData);

/// ! \brief Typedef for a generic RtMidiOut pointer.
typedef RtMidiOutPtr = ffi.Pointer<RtMidiWrapper>;

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int NULL = 0;
